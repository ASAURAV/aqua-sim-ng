//...

#include "aqua-sim-static-routing.h"

#include "ns3/address.h"	
#include "ns3/log.h"

//Aqua Sim Static Routing

#define IP_BROADCAST -1

namespace ns3 {

NS_LOG_COMPONENT_DEFINE ("AquaSimStaticRouting");
NS_OBJECT_ENSURE_REGISTERED (AquaSimStaticRouting);


AquaSimStaticRouting::AquaSimStaticRouting() : 
	AquaSimRouting(),
	m_hasSetRouteFile (false), 
	m_hasSetNode (false)
{
	NS_LOG_FUNCTION_NOARGS();
}

TypeId
AquaSimStaticRouting::GetTypeId(void)
{
	static TypeId tid = TypeId("ns3::AquaSimStaticRouting")
		.SetParent<AquaSimRouting>()
		.AddConstructor<AquaSimStaticRouting>()
		//start, on-node lookup
		;
	return tid;
}

void
AquaSimStaticRouting::SetRouteFile(char *routeFile)
{
	//load routing table
	m_hasSetRouteFile = true;
	if (m_hasSetNode)
	{
		ReadRouteTable(routeFile);
	}
}

/*
	* Load the static routing table in filename
	*
	* @param filename   the file containing routing table
	* */
void
AquaSimStaticRouting::ReadRouteTable(char *filename)
{
	FILE* stream = fopen(filename, "r");
	int32_t currentNode, dstNode, nxtHop;

	if (stream == NULL) {
		NS_LOG_ERROR(this << " Cannot find routing table file!");
		//exit(0);
	}

	while (!feof(stream)) {
		fscanf(stream, "%d:%d:%d", &currentNode, &dstNode, &nxtHop);

		if (m_myAddr == currentNode) {
			m_rTable[dstNode] = nxtHop;
		}
	}

	fclose(stream);
}


void
AquaSimStaticRouting::Recv(Ptr<Packet> p)  //Handler h
{

	if (IsDeadLoop(p)) {
		NS_LOG_FUNCTION(this << p << " Dropping : Route Loop");
		p = 0;
		return;
	}
	else if (AmISrc(p)) {
		NS_LOG_FUNCTION(this << "Packet=" << p << ", I Am Source.");
		//p->Size() += SR_HDR_LEN; //add the overhead of static routing's header
	}
	else if (!AmINextHop(p)) {
		NS_LOG_FUNCTION(this << p << " Dropping : Duplicate");
		p = 0;
		return;
	}

	//increase the number of forwards
	
	/*
	 * TODO, this needs to be incorporated using aqua-sim-header
	 */	
	//p->SetNumForwards() = p->GetNumForwards() + 1;

	if (AmIDst(p)) {
		AquaSimRouting::SendUp(p);
		return;
	}

	//find the next hop and forward
	Address nextHop = FindNextHop(p);
	if (nextHop != (Address)IP_BROADCAST) {
		AquaSimRouting::SendDown(p, nextHop, Seconds(0));
	}
	else {
		//fail to find the route, drop it
		NS_LOG_FUNCTION(this << p << " Dropping : No Route");
		p = 0;
	}
}

/*
	* @param p   a packet
	* @return    the next hop to route packet p
	* */
Address
AquaSimStaticRouting::FindNextHop(const Ptr<Packet> p) {
	map<Address, Address>::iterator it = m_rTable.find();//TODO p->GetDAddr());
	return it == m_rTable.end() ? -1 : it->second;	//IP_BROADCAST is -1 i believe from packet.h
}

}  //namespace ns3
